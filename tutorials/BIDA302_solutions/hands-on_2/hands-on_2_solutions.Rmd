---
title: "BIDA302: Lesson 2"
subtitle: "hands-on examples, with answers"
output: learnr::tutorial
runtime: shiny_prerendered
---



<!-- This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. -->


```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# packages used in the tutorial
library(tidyverse)
library(gapminder)

```


# 1. Missing Values



## Your Turn 1.1: Find the `NA` values

`is.na` and `anyNA(x)` functions are logical

What does `is.na(x)` return? 


```{r missing1, exercise=TRUE, exercise.eval=FALSE}
x <- c(1, NA, 3)

# answer
is.na(x)

```


There are three values in `x`, so three tests--only the second one is `NA`.

What about `anyNA(x)`?

```{r missing2, exercise=TRUE, exercise.eval=FALSE}
# example
x <- c(1, NA, 3)

```



```{r missing2-solution}
x <- c(1, NA, 3)

# answer
anyNA(x)

# There are three values in `x`, so three tests--only the second one is `NA`

```




What if we put an exclamation mark -- the "not" symbol -- in front of `is.na()`? How does it differ from `is.na()`?

```{r missing3, exercise=TRUE, exercise.eval=FALSE}
# example
x <- c(1, NA, 3)

```



```{r missing3-solution}
# example
x <- c(1, NA, 3)

!is.na(x)
```


## Calculating with `NA`


Run this code to see what happens when there are `NA` values in a variable, and you try to sum them.

Use `na.rm` within the `sum()` function to calculate the sum of `x`.


```{r missing4, exercise=TRUE, exercise.eval=FALSE}
# example
x <- c(1, NA, 3)

# example
sum(x)

```



```{r missing4-solution}

# answer
x <- c(1, NA, 3)
sum(x, na.rm = TRUE)


```


STOP HERE ...


## Your Turn 1.2: 

First step: review the structure of the `mpg` data set:

```{r missing1_2_1, exercise=TRUE, exercise.eval=FALSE}
mpg
```


Run to create the `displ_class_by_cyl` table:

* group the cars by class and cylinder size, and 

* show the mean displacement (engine size)

```{r missing1_2_2, exercise=TRUE, exercise.eval=FALSE}
# summary table - class by cylinder
displ_class_by_cyl <- mpg %>%
  group_by(class, cyl) %>%
  summarise(displ_mean = mean(displ)) %>%
  arrange(desc(displ_mean)) %>%
  pivot_wider(names_from = cyl, values_from = displ_mean) %>%
  pivot_longer(-class, names_to = "cyl", values_to = "displ_mean")

displ_class_by_cyl

#saveRDS(displ_class_by_cyl, file = "tutorials/BIDA302_solutions/hands-on_2/displ_class_by_cyl.rds")

```

```{r, include=FALSE}
#load displ_class_by_cyl table (since the output of one chunk doesn't carry forward)

displ_class_by_cyl <- readRDS(file = "displ_class_by_cyl.rds")


```


Calculate the mean of `displ_mean` -- note that there are `NA` values.

```{r missing1_2_3, exercise=TRUE, exercise.eval=FALSE}
# example
mean(displ_class_by_cyl$displ_mean)


```



```{r missing1_2_3-solution}


# solution
mean(displ_class_by_cyl$displ_mean, na.rm = TRUE)

```


An alternative solution: use a filter with `!na` to remove the records with `NA` values:

```{r missing1_2_4, exercise=TRUE, exercise.eval=FALSE}
# example
displ_class_by_cyl %>%
  summarise(displ_mean_all = mean(displ_mean))
```



```{r missing1_2_4-solution}


# solution
displ_class_by_cyl %>%
  filter(!is.na(displ_mean)) %>%
  summarise(displ_mean_all = mean(displ_mean))

```



## Summarize with `group()` and `ungroup()`


You'll notice in #1.2 that when we summarize `displ_class_by_cyl` it gives the mean values by class, even though we didn't use any grouping variable.

This is because when we ran the code to create the `displ_class_by_cyl` table, we grouped by `class` and `cyl`. Running the `summarise()` function is applied, it removes one level of the grouping (in this case, `cyl`): 

```{r missing1_2_5, exercise=TRUE, exercise.eval=FALSE}

# example
displ_class_by_cyl

displ_class_by_cyl %>%
  filter(!is.na(displ_mean)) %>%
  summarise(displ_mean_all = mean(displ_mean))


```


If you want the mean of all the values, you have to use `ungroup()` before `summarise()`, to "peel off" `class`


```{r missing1_2_6, exercise=TRUE, exercise.eval=FALSE}

# solution
displ_class_by_cyl %>%
  filter(!is.na(displ_mean)) %>%
  ungroup() %>%
  summarise(displ_mean_all = mean(displ_mean))


```

STOP HERE ...


## Take aways

* using functions to identify unknown values (`NA`) in a variable
* finding `NA` values
* removing or avoiding `NA` values in calculations




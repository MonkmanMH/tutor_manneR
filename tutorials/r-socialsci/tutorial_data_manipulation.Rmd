---
title: "Tutorial: data manipulation"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# packages used in the tutorial
library(dplyr)
library(tidyr)
library(readr)

# load data
interviews <- read_csv("data/SAFI_clean.csv", na = "NULL")


```

<!-- This tutorial was made using the R package {learnr} https://rstudio.github.io/learnr/

     The content is a modification of the material developed by the Data Carpentries lesson
     "R for Social Scientists" https://datacarpentry.org/r-socialsci/
     Licensed under CC-BY 4.0 2018â€“2020 by The Carpentries (https://carpentries.org/)
     
     Modifications are licensesd under CC-BY 4.0 by Martin Monkman 

-->




## Data Manipulation using **`dplyr`** and **`tidyr`**

**`dplyr`** is a package for making tabular data manipulation easier by using a limited set of functions that can be combined to extract and summarize insights from your data. It pairs nicely with **`tidyr`** which enables you to swiftly convert between different data formats (long vs. wide) for plotting and analysis.

Along with a number of other packages, **`dplyr`** and **`tidyr`** are part of the tidyverse. These packages are loaded in R's memory when we call them individually using `library(dplyr)` and `library(tidry)`, or we can load them along with the other packages in the tidyverse: `library(tidyverse)`.




### What is an R package?

An R package is a complete unit for sharing code with others. Each R package contains the code for a set of R functions, the documentation (or description) for each of the functions, as well as a practice dataset to learn the functions on. 

Generally, each R package is built with a specific task in mind. For instance, the package **`dplyr`** provides easy tools for the most common data manipulation tasks. It is built to work directly with data frames, with many common tasks optimized by being written in a compiled language (C++) (not all R packages are written in R!). 

The package **`tidyr`** addresses the common problem of wanting to reshape your data for plotting and use by different R functions. Sometimes we want data sets where we have one row per measurement. Sometimes we want a data frame where each measurement type has its own column, and rows are instead more aggregated groups. Moving back and forth between these formats is nontrivial, and **`tidyr`** gives you tools for this and more sophisticated  data manipulation.

But there are also packages available for a wide range of tasks including building plots (**`ggplot2`**, which we'll see later), downloading data from the NCBI database, or performing statistical analysis on your data set. Many packages such as these are housed on, and downloadable from, the **C**omprehensive **R** **A**rchive **N**etwork (CRAN) using `install.packages`. This function makes the package accessible by your R installation with the command `library()`, as you did with `tidyverse` earlier.

To easily access the documentation for a package within R or RStudio, use `help(package = "package_name")`.

To learn more about **`dplyr`** and **`tidyr`** after the workshop, you may want to check out this
[handy data transformation with **`dplyr`** cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf) and this [one about **`tidyr`**](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf).


### The dataset

This lesson uses the SAFI dataset; SAFI (Studying African Farmer-Led Irrigation) is a study looking at farming and irrigation methods in Tanzania and Mozambique. The survey data was collected through interviews conducted between November 2016 and June 2017. 

Each row holds
information for a single interview respondent, and the columns
represent:

| column_name | description |
| ----------- | ----------- |
| key_id | Added to provide a unique Id for each observation. (The InstanceID field does this as well but it is not as convenient to use) |
| village | Village name |
| interview_date | Date of interview |
| no_membrs | How many members in the household? |
| years_liv | How many years have you been living in this village or neighboring village? |
| respondent_wall_type | What type of walls does their house have (from list) |
| rooms | How many rooms in the main house are used for sleeping? |
| memb_assoc | Are you a member of an irrigation association? |
| affect_conflicts | Have you been affected by conflicts with other irrigators in the area? |
| liv_count | Number of livestock owned. |
| items_owned | Which of the following items are owned by the household? (list) |
| no_meals | How many meals do people in your household normally eat in a day? |
| months_lack_food | Indicate which months, In the last 12 months have you faced a situation when you did not have enough food to feed the household? |
| instanceID | Unique identifier for the form data submission |

<!-- ```{r, results = 'hide', purl = FALSE, message=FALSE} -->

```{r SAFI_data_load, message=FALSE}
# ## load the tidyverse
# interviews <- read_csv("data/SAFI_clean.csv", na = "NULL")
```

This data set is already loaded into your R space as the object `interviews`. 

Take a look at the first 10 rows of the `interviews` data frame, using the `head()` function:

```{r SAFI_data_view, exercise=TRUE}


```


```{r SAFI_data_view-hint}
head(interviews)

```

## `dplyr` functions

We're going to learn some of the most common **`dplyr`** functions:

- `select()`: subset columns
- `filter()`: subset rows on conditions
- `mutate()`: create new columns by using information from other columns
- `group_by()` and `summarize()`: create summary statistics on grouped data
- `arrange()`: sort results
- `count()`: count discrete values

### Selecting columns and filtering rows

To select columns of a data frame, use `select()`. The first argument to this function is the data
frame (`interviews`), and the subsequent arguments are the columns to keep.

```{r select_example, exercise=TRUE, exercise.eval=FALSE}
select(interviews, village, no_membrs, years_liv)
```

To choose rows based on a specific criteria, use `filter()`:

```{r filter_example, exercise=TRUE, exercise.eval=TRUE}
filter(interviews, village == "God")
```

## Pipes

What if you want to select and filter at the same time? There are three
ways to do this: use intermediate steps, nested functions, or pipes.

With intermediate steps, you create a temporary data frame and use
that as input to the next function, like this:

```{r, pipes_1_example, exercise=TRUE, exercise.eval=FALSE}
interviews2 <- filter(interviews, village == "God")
interviews_god <- select(interviews2, no_membrs, years_liv)

interviews_god
```

This is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.

You can also nest functions (i.e. one function inside of another), like this:

```{r, pipes_2_example, exercise=TRUE, exercise.eval=FALSE}
interviews_god <- select(filter(interviews, village == "God"), no_membrs, years_liv)

interviews_god
```

This is handy, but can be difficult to read if too many functions are nested, as
R evaluates the expression from the inside out (in this case, filtering, then selecting).

The last option, *pipes*, are a recent addition to R. Pipes let you take the
output of one function and send it directly to the next, which is useful when
you need to do many things to the same dataset. Pipes in R look like `%>%` and
are made available via the **`magrittr`** package, installed automatically with
**`dplyr`**. If you use RStudio, you can type the pipe with <kbd>Ctrl</kbd>
+ <kbd>Shift</kbd> + <kbd>M</kbd> if you have a PC or <kbd>Cmd</kbd> +
<kbd>Shift</kbd> + <kbd>M</kbd> if you have a Mac.

```{r, pipes_3_example, exercise=TRUE, exercise.eval=FALSE}
interviews %>%
    filter(village == "God") %>%
    select(no_membrs, years_liv)
```

In the above code, we use the pipe to send the `interviews` dataset first
through `filter()` to keep rows where `village` is "God", then through
`select()` to keep only the `no_membrs` and `years_liv` columns. Since `%>%`
takes the object on its left and passes it as the first argument to the function
on its right, we don't need to explicitly include the data frame as an argument
to the `filter()` and `select()` functions any more.

Some may find it helpful to read the pipe like the word "then". For instance,
in the above example, we take the data frame `interviews`, *then* we `filter`
for rows with `village == "God"`, *then* we `select` columns `no_membrs` and `years_liv`. The **`dplyr`** functions by themselves are somewhat simple,
but by combining them into linear workflows with the pipe, we can accomplish
more complex manipulations of data frames.

If we want to create a new object with this smaller version of the data, we
can assign it a new name:

```{r, pipes_assignment_example, exercise=TRUE, exercise.eval=FALSE}
interviews_god <- interviews %>%
    filter(village == "God") %>%
    select(no_membrs, years_liv)

interviews_god
```

Note that the final data frame (`interviews_god`) is the leftmost part of this expression.

## Exercise 1: data manipulation

Using pipes, subset the `interviews` data to include interviews
where respondents were members of an irrigation association
(`memb_assoc`) and retain only the columns `affect_conflicts`,
`liv_count`, and `no_meals`.


#### Solution

```{r data_manip_ex1, exercise=TRUE, exercise.eval=TRUE}

```


```{r data_manip_ex1-solution}
interviews %>%
   filter(memb_assoc == "yes") %>%
   select(affect_conflicts, liv_count, no_meals)
```

 
## Mutate

Frequently you'll want to create new columns based on the values in existing
columns, for example to do unit conversions, or to find the ratio of values in
two columns. For this we'll use `mutate()`.

We might be interested in the ratio of number of household members
to rooms used for sleeping (i.e. avg number of people per room):

```{r, mutate01_example, exercise=TRUE, exercise.eval=FALSE}
interviews %>%
    mutate(people_per_room = no_membrs / rooms)
```

We may be interested in investigating whether being a member of an
irrigation association had any effect on the ratio of household members
to rooms. To look at this relationship, we will first remove
data from our dataset where the respondent didn't answer the
question of whether they were a member of an irrigation association.
These cases are recorded as "NULL" in the dataset.

To remove these cases, we could insert a `filter()` in the chain:

```{r, mutate02_example, exercise=TRUE, exercise.eval=FALSE}
interviews %>%
    filter(!is.na(memb_assoc)) %>%
    mutate(people_per_room = no_membrs / rooms)
```

The `!` symbol negates the result, so we're asking for every row where
`memb_assoc` *is not* missing..



## Exercise 2: mutate

Create a new data frame from the `interviews` data that meets the following
criteria: contains only the `village` column and a new column called
`total_meals` containing a value that is equal to the total number of meals
served in the household per day on average (`no_membrs` times `no_meals`).
Only the rows where `total_meals` is greater than 20 should be shown in the
final data frame.
**Hint**: think about how the commands should be ordered to produce this data
frame!


```{r data_manip_ex2, exercise=TRUE, exercise.eval=TRUE}

```


```{r data_manip_ex2-solution}
interviews_total_meals <- interviews %>%
   mutate(total_meals = no_membrs * no_meals) %>%
   filter(total_meals > 20) %>%
   select(village, total_meals)
```


**THE END (_temporarily_)**
